using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using BeverageDistributor.Application.DTOs.Integration;
using BeverageDistributor.Application.Interfaces;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using IModel = RabbitMQ.Client.IModel;

namespace BeverageDistributor.Infrastructure.Services
{
    public class OrderProcessingService : BackgroundService, IAsyncDisposable
    {
        private IConnection? _connection;
        private IModel? _channel;
        private readonly ILogger<OrderProcessingService> _logger;
        private readonly IExternalOrderService _externalOrderService;
        private readonly RabbitMqSettings _rabbitMqSettings;
        private readonly OrderProcessingSettings _orderProcessingSettings;
        private readonly SemaphoreSlim _connectionLock = new(1, 1);
        private bool _disposed;
        private bool _initialized;

        // Nomes das filas e exchanges
        private const string MainQueueName = "order_processing";
        private const string RetryQueueName = "order_processing_retry";
        private const string DeadLetterQueueName = "order_processing_dead_letter";
        private const string MainExchangeName = "order_exchange";
        private const string RetryExchangeName = "order_retry_exchange";
        private const string DeadLetterExchangeName = "order_dead_letter_exchange";

        public OrderProcessingService(
            IOptions<RabbitMqSettings> rabbitMqSettings,
            IOptions<OrderProcessingSettings> orderProcessingSettings,
            IExternalOrderService externalOrderService,
            ILogger<OrderProcessingService> logger)
        {
            _rabbitMqSettings = rabbitMqSettings?.Value ?? throw new ArgumentNullException(nameof(rabbitMqSettings));
            _orderProcessingSettings = orderProcessingSettings?.Value ?? throw new ArgumentNullException(nameof(orderProcessingSettings));
            _externalOrderService = externalOrderService ?? throw new ArgumentNullException(nameof(externalOrderService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        private async Task EnsureInitializedAsync()
        {
            if (_initialized) return;

            await _connectionLock.WaitAsync();
            try
            {
                if (_initialized) return;

                var factory = new ConnectionFactory
                {
                    HostName = _rabbitMqSettings.HostName,
                    Port = _rabbitMqSettings.Port,
                    UserName = _rabbitMqSettings.Username,
                    Password = _rabbitMqSettings.Password,
                    VirtualHost = _rabbitMqSettings.VirtualHost,
                    AutomaticRecoveryEnabled = true,
                    NetworkRecoveryInterval = TimeSpan.FromSeconds(10)
                };

                _connection = factory.CreateConnection();
                _channel = _connection.CreateModel();

                // Configuração das exchanges
                _channel.ExchangeDeclare(MainExchangeName, ExchangeType.Direct, durable: true, autoDelete: false);
                _channel.ExchangeDeclare(RetryExchangeName, ExchangeType.Direct, durable: true, autoDelete: false);
                _channel.ExchangeDeclare(DeadLetterExchangeName, ExchangeType.Direct, durable: true, autoDelete: false);

                // Argumentos para as filas
                var mainQueueArgs = new Dictionary<string, object>
                {
                    { "x-dead-letter-exchange", RetryExchangeName },
                    { "x-message-ttl", 30000 } // 30 segundos
                };

                var retryQueueArgs = new Dictionary<string, object>
                {
                    { "x-dead-letter-exchange", MainExchangeName },
                    { "x-message-ttl", 30000 },
                    { "x-dead-letter-routing-key", MainQueueName }
                };

                // Declaração das filas
                _channel.QueueDeclare(
                    queue: MainQueueName,
                    durable: true,
                    exclusive: false,
                    autoDelete: false,
                    arguments: mainQueueArgs);

                _channel.QueueDeclare(
                    queue: RetryQueueName,
                    durable: true,
                    exclusive: false,
                    autoDelete: false,
                    arguments: retryQueueArgs);

                _channel.QueueDeclare(
                    queue: DeadLetterQueueName,
                    durable: true,
                    exclusive: false,
                    autoDelete: false,
                    arguments: null);

                // Bindings
                _channel.QueueBind(MainQueueName, MainExchangeName, MainQueueName);
                _channel.QueueBind(RetryQueueName, RetryExchangeName, RetryQueueName);
                _channel.QueueBind(DeadLetterQueueName, DeadLetterExchangeName, DeadLetterQueueName);

                _connection.ConnectionShutdown += (sender, e) =>
                {
                    _logger.LogWarning("Conexão com RabbitMQ encerrada: {ReplyText}", e.ReplyText);
                    _initialized = false;
                };

                _initialized = true;
                _logger.LogInformation("Conexão com RabbitMQ estabelecida com sucesso");
            }
            finally
            {
                _connectionLock.Release();
            }
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Iniciando serviço de processamento de pedidos...");
            
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await EnsureInitializedAsync();

                    var consumer = new AsyncEventingBasicConsumer(_channel);
                    
                    consumer.Received += async (model, ea) =>
                    {
                        string message = string.Empty;
                        string messageId = ea.BasicProperties.MessageId ?? Guid.NewGuid().ToString();
                        string correlationId = ea.BasicProperties.CorrelationId ?? Guid.NewGuid().ToString();
                        var retryCount = GetRetryCount(ea.BasicProperties.Headers);
                        
                        using (_logger.BeginScope(new Dictionary<string, object>
                        {
                            ["MessageId"] = messageId,
                            ["CorrelationId"] = correlationId,
                            ["RetryCount"] = retryCount
                        }))
                        {
                            try
                            {
                                var body = ea.Body.ToArray();
                                message = Encoding.UTF8.GetString(body);
                                var orderRequest = JsonSerializer.Deserialize<ExternalOrderRequestDto>(message);

                                _logger.LogInformation("Processando pedido. Distribuidor: {DistributorId}, Itens: {ItemCount}, Tentativa: {RetryCount}",
                                    orderRequest?.DistributorId, orderRequest?.Items?.Count, retryCount + 1);

                                if (orderRequest == null)
                                {
                                    throw new OrderValidationException("Mensagem inválida: objeto nulo");
                                }

                                // Valida o pedido
                                ValidateOrderRequest(orderRequest, _orderProcessingSettings.MinOrderQuantity);

                                // Processa o pedido
                                var response = await _externalOrderService.SubmitOrderAsync(orderRequest);
                                
                                _logger.LogInformation("Pedido processado com sucesso. OrderId: {OrderId}, Status: {Status}",
                                    response.OrderId, response.Status);

                                // Confirma o processamento da mensagem
                                _channel.BasicAck(ea.DeliveryTag, false);
                            }
                            catch (ValidationException vex)
                            {
                                _logger.LogWarning(vex, "Validação falhou para o pedido: {ErrorMessage}", vex.Message);
                                // Rejeita a mensagem sem recolocar na fila
                                _channel.BasicNack(ea.DeliveryTag, false, false);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "Erro ao processar pedido");
                                
                                if (retryCount >= _orderProcessingSettings.MaxRetryAttempts - 1)
                                {
                                    _logger.LogWarning("Máximo de tentativas ({MaxRetry}) atingido. Enviando para DLQ.", 
                                        _orderProcessingSettings.MaxRetryAttempts);
                                    PublishToDeadLetterQueue(ea, message, ex);
                                    _channel.BasicAck(ea.DeliveryTag, false);
                                }
                                else
                                {
                                    // Rejeita a mensagem para ir para a fila de retentativa
                                    _channel.BasicNack(ea.DeliveryTag, false, false);
                                }
                            }
                        }
                    };

                    _channel.BasicConsume(queue: MainQueueName, autoAck: false, consumer: consumer);
                    _logger.LogInformation("Consumidor registrado na fila {QueueName}", MainQueueName);

                    // Manter o consumidor ativo
                    while (_connection?.IsOpen == true && !stoppingToken.IsCancellationRequested)
                    {
                        await Task.Delay(1000, stoppingToken);
                    }
                }
                catch (Exception ex) when (!stoppingToken.IsCancellationRequested)
                {
                    _logger.LogError(ex, "Erro no consumidor. Tentando reconectar em 5 segundos...");
                    _initialized = false;
                    await Task.Delay(5000, stoppingToken);
                }
            }
        }

        private void ValidateOrderRequest(ExternalOrderRequestDto orderRequest, int minOrderQuantity)
        {
            if (orderRequest == null)
                throw new OrderValidationException("Pedido não pode ser nulo");

            if (string.IsNullOrWhiteSpace(orderRequest.DistributorId))
                throw new OrderValidationException("O ID do distribuidor é obrigatório");

            if (orderRequest.Items == null || orderRequest.Items.Count == 0)
                throw new OrderValidationException("O pedido deve conter pelo menos um item");

            var totalQuantity = orderRequest.Items.Sum(item => item.Quantity);
            if (totalQuantity < minOrderQuantity)
                throw new OrderValidationException($"Quantidade total do pedido ({totalQuantity}) é menor que o mínimo exigido ({minOrderQuantity})");

            foreach (var item in orderRequest.Items)
            {
                if (string.IsNullOrWhiteSpace(item.ProductId))
                    throw new OrderValidationException("O ID do produto é obrigatório");

                if (string.IsNullOrWhiteSpace(item.ProductName))
                    throw new OrderValidationException("O nome do produto é obrigatório");

                if (item.Quantity <= 0)
                    throw new OrderValidationException($"A quantidade do produto {item.ProductId} deve ser maior que zero");

                if (item.UnitPrice < 0)
                    throw new OrderValidationException($"O preço unitário do produto {item.ProductId} não pode ser negativo");
            }
        }

        private int GetRetryCount(IDictionary<string, object> headers)
        {
            if (headers != null && headers.TryGetValue("x-retry-count", out var retryCountObj) && 
                int.TryParse(retryCountObj?.ToString(), out var retryCount))
            {
                return retryCount;
            }
            return 0;
        }

        private void PublishToDeadLetterQueue(BasicDeliverEventArgs ea, string message, Exception exception)
        {
            try
            {
                var properties = _channel.CreateBasicProperties();
                properties.Persistent = true;
                properties.MessageId = ea.BasicProperties.MessageId ?? Guid.NewGuid().ToString();
                properties.CorrelationId = ea.BasicProperties.CorrelationId ?? Guid.NewGuid().ToString();
                properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());
                properties.Headers = new Dictionary<string, object>(ea.BasicProperties.Headers ?? new Dictionary<string, object>())
                {
                    ["x-death-reason"] = exception.Message,
                    ["x-death-timestamp"] = DateTime.UtcNow.ToString("o")
                };

                _channel.BasicPublish(
                    exchange: DeadLetterExchangeName,
                    routingKey: DeadLetterQueueName,
                    mandatory: true,
                    basicProperties: properties,
                    body: Encoding.UTF8.GetBytes(message));

                _logger.LogWarning("Mensagem enviada para DLQ. Motivo: {ErrorMessage}", exception.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Falha ao publicar mensagem na DLQ");
                throw;
            }
        }

        public async ValueTask DisposeAsync()
        {
            if (_disposed) return;
            
            _disposed = true;
            _channel?.Close();
            _channel?.Dispose();
            _connection?.Close();
            _connection?.Dispose();
            _connectionLock.Dispose();
            
            await Task.CompletedTask;
        }
    }

    public class OrderValidationException : Exception
    {
        public OrderValidationException(string message) : base(message) { }
        public OrderValidationException(string message, Exception innerException) : base(message, innerException) { }
    }
}
